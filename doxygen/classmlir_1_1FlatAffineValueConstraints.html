<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::FlatAffineValueConstraints Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">14.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmlir_1_1FlatAffineValueConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::FlatAffineValueConstraints Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An extension of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> in which dimensions and symbols can optionally be associated with an SSA value.  
 <a href="classmlir_1_1FlatAffineValueConstraints.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AffineStructures_8h_source.html">mlir/Analysis/AffineStructures.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::FlatAffineValueConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__inherit__graph.png" border="0" usemap="#mlir_1_1FlatAffineValueConstraints_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1FlatAffineValueConstraints_inherit__map" id="mlir_1_1FlatAffineValueConstraints_inherit__map">
<area shape="rect" id="node4" href="classmlir_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain &#45;&gt; range) where &quot;domain&quot; and &quot;range&quot; a..." alt="" coords="34,229,205,256"/>
<area shape="rect" id="node2" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. " alt="" coords="23,80,215,107"/>
<area shape="rect" id="node3" href="classmlir_1_1IntegerPolyhedron.html" title="An integer polyhedron is the set of solutions to a list of affine constraints over n integer&#45;valued v..." alt="" coords="32,5,207,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::FlatAffineValueConstraints:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1FlatAffineValueConstraints__coll__graph.png" border="0" usemap="#mlir_1_1FlatAffineValueConstraints_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1FlatAffineValueConstraints_coll__map" id="mlir_1_1FlatAffineValueConstraints_coll__map">
<area shape="rect" id="node2" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. " alt="" coords="171,257,363,284"/>
<area shape="rect" id="node3" href="classmlir_1_1IntegerPolyhedron.html" title="An integer polyhedron is the set of solutions to a list of affine constraints over n integer&#45;valued v..." alt="" coords="44,131,219,158"/>
<area shape="rect" id="node4" href="classmlir_1_1Matrix.html" title="This is a class to represent a resizable matrix. " alt="" coords="5,5,103,32"/>
<area shape="rect" id="node5" href="classunsigned.html" title="unsigned" alt="" coords="176,5,257,32"/>
<area shape="rect" id="node6" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l llvm::Optional\&lt; mlir\l::Value \&gt;, 8 \&gt;" alt="" coords="395,243,553,299"/>
<area shape="rect" id="node7" href="classllvm_1_1SmallVector.html" title="llvm::SmallVector\&lt;\l T, N \&gt;" alt="" coords="407,124,555,165"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#aaec51cfb6129c7a10dbf24740897cf1b">FlatAffineValueConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:aaec51cfb6129c7a10dbf24740897cf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="#aaec51cfb6129c7a10dbf24740897cf1b">More...</a><br /></td></tr>
<tr class="separator:aaec51cfb6129c7a10dbf24740897cf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a8ba51af6e35a94b11d73b5215a35ff7a">FlatAffineValueConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="memdesc:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="#a8ba51af6e35a94b11d73b5215a35ff7a">More...</a><br /></td></tr>
<tr class="separator:a8ba51af6e35a94b11d73b5215a35ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac652e97cab7cf64e3bef1b3418692a2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac652e97cab7cf64e3bef1b3418692a2a">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;fac, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt; valArgs={})</td></tr>
<tr class="separator:ac652e97cab7cf64e3bef1b3418692a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af048f5fb19968688b331c7bb0f8d9a4d">FlatAffineValueConstraints</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;avm)</td></tr>
<tr class="memdesc:af048f5fb19968688b331c7bb0f8d9a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these.  <a href="#af048f5fb19968688b331c7bb0f8d9a4d">More...</a><br /></td></tr>
<tr class="separator:af048f5fb19968688b331c7bb0f8d9a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa32c847534d57cff25fdfa654778e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a0aa32c847534d57cff25fdfa654778e0">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef)</td></tr>
<tr class="separator:a0aa32c847534d57cff25fdfa654778e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa812729dd90454f1c10517520dde9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3fa812729dd90454f1c10517520dde9a">FlatAffineValueConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a3fa812729dd90454f1c10517520dde9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>.  <a href="#a3fa812729dd90454f1c10517520dde9a">More...</a><br /></td></tr>
<tr class="separator:a3fa812729dd90454f1c10517520dde9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a948d12b8760154eed1281249b0f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4c5a948d12b8760154eed1281249b0f7">FlatAffineValueConstraints</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt; avmRef, <a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="separator:a4c5a948d12b8760154eed1281249b0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac6234845a4fa3eb9444e56cab0fe5b0e">getKind</a> () const override</td></tr>
<tr class="memdesc:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the kind of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="#ac6234845a4fa3eb9444e56cab0fe5b0e">More...</a><br /></td></tr>
<tr class="separator:ac6234845a4fa3eb9444e56cab0fe5b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9813ab39fe84ac3208f6475c0058e02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad9813ab39fe84ac3208f6475c0058e02">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0) override</td></tr>
<tr class="memdesc:ad9813ab39fe84ac3208f6475c0058e02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any existing data and reserves memory for the specified constraints.  <a href="#ad9813ab39fe84ac3208f6475c0058e02">More...</a><br /></td></tr>
<tr class="separator:ad9813ab39fe84ac3208f6475c0058e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58e00fa2f257f1bd2c8ab11369207198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a58e00fa2f257f1bd2c8ab11369207198">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:a58e00fa2f257f1bd2c8ab11369207198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a94ce5a825b81e5767fef38db2329a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae3a94ce5a825b81e5767fef38db2329a">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; valArgs)</td></tr>
<tr class="separator:ae3a94ce5a825b81e5767fef38db2329a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592860df144ae17907bccf79792e3f90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a592860df144ae17907bccf79792e3f90">clone</a> () const</td></tr>
<tr class="memdesc:a592860df144ae17907bccf79792e3f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clones this object.  <a href="#a592860df144ae17907bccf79792e3f90">More...</a><br /></td></tr>
<tr class="separator:a592860df144ae17907bccf79792e3f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85192d2ad28e90993950ec5c2598a3e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a85192d2ad28e90993950ec5c2598a3e7">addAffineForOpDomain</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a85192d2ad28e90993950ec5c2598a3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps.  <a href="#a85192d2ad28e90993950ec5c2598a3e7">More...</a><br /></td></tr>
<tr class="separator:a85192d2ad28e90993950ec5c2598a3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4287995c9f074be38e7e1d76b39d93f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4287995c9f074be38e7e1d76b39d93f8">addDomainFromSliceMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a4287995c9f074be38e7e1d76b39d93f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice.  <a href="#a4287995c9f074be38e7e1d76b39d93f8">More...</a><br /></td></tr>
<tr class="separator:a4287995c9f074be38e7e1d76b39d93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1b74b3973d5329fe7ec99a7d2f8ed31f">addAffineIfOpDomain</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds constraints imposed by the <code>affine.if</code> operation.  <a href="#a1b74b3973d5329fe7ec99a7d2f8ed31f">More...</a><br /></td></tr>
<tr class="separator:a1b74b3973d5329fe7ec99a7d2f8ed31f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ae0266a236d1adc4c4a08e4d68b741e38">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:ae0266a236d1adc4c4a08e4d68b741e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands.  <a href="#ae0266a236d1adc4c4a08e4d68b741e38">More...</a><br /></td></tr>
<tr class="separator:ae0266a236d1adc4c4a08e4d68b741e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210341fc77fde46aedce6d2609f26738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a210341fc77fde46aedce6d2609f26738">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> val, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:a210341fc77fde46aedce6d2609f26738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the identifier associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a210341fc77fde46aedce6d2609f26738">More...</a><br /></td></tr>
<tr class="separator:a210341fc77fde46aedce6d2609f26738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dbadcb953c32567a17ab1b662505e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ac0dbadcb953c32567a17ab1b662505e0">getIneqAsAffineValueMap</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> ineqPos, <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;vmap, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:ac0dbadcb953c32567a17ab1b662505e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bound for the identifier at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands).  <a href="#ac0dbadcb953c32567a17ab1b662505e0">More...</a><br /></td></tr>
<tr class="separator:ac0dbadcb953c32567a17ab1b662505e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad38a7dd065a6c286b7ac84f0d1712c23">addSliceBounds</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; lbMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; ubMaps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each identifier in the constraint system which has a value in <code>values</code>.  <a href="#ad38a7dd065a6c286b7ac84f0d1712c23">More...</a><br /></td></tr>
<tr class="separator:ad38a7dd065a6c286b7ac84f0d1712c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab578264c931fe0f78eb0397943d032c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ab578264c931fe0f78eb0397943d032c1">findId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val, <a class="el" href="classunsigned.html">unsigned</a> *pos) const</td></tr>
<tr class="memdesc:ab578264c931fe0f78eb0397943d032c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#ab578264c931fe0f78eb0397943d032c1">More...</a><br /></td></tr>
<tr class="separator:ab578264c931fe0f78eb0397943d032c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9d547b7f44aaa82af5d5ab1aeb74a42a">containsId</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val) const</td></tr>
<tr class="memdesc:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise.  <a href="#a9d547b7f44aaa82af5d5ab1aeb74a42a">More...</a><br /></td></tr>
<tr class="separator:a9d547b7f44aaa82af5d5ab1aeb74a42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda87dfc4340eb857e9bc9ab05141b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acda87dfc4340eb857e9bc9ab05141b16">swapId</a> (<a class="el" href="classunsigned.html">unsigned</a> posA, <a class="el" href="classunsigned.html">unsigned</a> posB) override</td></tr>
<tr class="memdesc:acda87dfc4340eb857e9bc9ab05141b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the posA^th identifier with the posB^th identifier.  <a href="#acda87dfc4340eb857e9bc9ab05141b16">More...</a><br /></td></tr>
<tr class="separator:acda87dfc4340eb857e9bc9ab05141b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37618dd64a6fe91226805818e4139fb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a37618dd64a6fe91226805818e4139fb9">insertDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="memdesc:a37618dd64a6fe91226805818e4139fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert identifiers of the specified kind at position <code>pos</code>.  <a href="#a37618dd64a6fe91226805818e4139fb9">More...</a><br /></td></tr>
<tr class="separator:a37618dd64a6fe91226805818e4139fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c6ee75c0627beaeb455d0428636849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a99c6ee75c0627beaeb455d0428636849">insertSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a99c6ee75c0627beaeb455d0428636849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dde72b54f749643d4002efc28a643a0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a7dde72b54f749643d4002efc28a643a0">insertId</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1) override</td></tr>
<tr class="separator:a7dde72b54f749643d4002efc28a643a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a31a532a6942ad1f960d6663ab8fede"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5a31a532a6942ad1f960d6663ab8fede">insertId</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a5a31a532a6942ad1f960d6663ab8fede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a18111fe7ef555fcb69a9d6a175ea8cd8">appendDimId</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="memdesc:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append identifiers of the specified kind after the last identifier of that kind.  <a href="#a18111fe7ef555fcb69a9d6a175ea8cd8">More...</a><br /></td></tr>
<tr class="separator:a18111fe7ef555fcb69a9d6a175ea8cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2a6f8c373783c6b808038d8c07e796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2c2a6f8c373783c6b808038d8c07e796">appendSymbolId</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vals)</td></tr>
<tr class="separator:a2c2a6f8c373783c6b808038d8c07e796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1150883739ccac33efedf30dd36decfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1150883739ccac33efedf30dd36decfb">addInductionVarOrTerminalSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a1150883739ccac33efedf30dd36decfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system.  <a href="#a1150883739ccac33efedf30dd36decfb">More...</a><br /></td></tr>
<tr class="separator:a1150883739ccac33efedf30dd36decfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1918c91299c463de63c843ee1f7628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5f1918c91299c463de63c843ee1f7628">computeAlignedMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands) const</td></tr>
<tr class="memdesc:a5f1918c91299c463de63c843ee1f7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align <code>map</code> with this constraint system based on <code>operands</code>.  <a href="#a5f1918c91299c463de63c843ee1f7628">More...</a><br /></td></tr>
<tr class="separator:a5f1918c91299c463de63c843ee1f7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad4dd23a785eb9a02c7f2ba43fa1aa7db">composeMap</a> (const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *vMap)</td></tr>
<tr class="memdesc:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map.  <a href="#ad4dd23a785eb9a02c7f2ba43fa1aa7db">More...</a><br /></td></tr>
<tr class="separator:ad4dd23a785eb9a02c7f2ba43fa1aa7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a79575e2c2693576f2c5a4accf0dcdab6">projectOut</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a79575e2c2693576f2c5a4accf0dcdab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a79575e2c2693576f2c5a4accf0dcdab6">More...</a><br /></td></tr>
<tr class="separator:a79575e2c2693576f2c5a4accf0dcdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b004fb4978436d8c8cd8976803468c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a38b004fb4978436d8c8cd8976803468c">convertLoopIVSymbolsToDims</a> ()</td></tr>
<tr class="memdesc:a38b004fb4978436d8c8cd8976803468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes all symbol identifiers which are loop IVs to dim identifiers.  <a href="#a38b004fb4978436d8c8cd8976803468c">More...</a><br /></td></tr>
<tr class="separator:a38b004fb4978436d8c8cd8976803468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af0c35f1d2d81adf4ba06b84df578cd78">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:af0c35f1d2d81adf4ba06b84df578cd78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="#af0c35f1d2d81adf4ba06b84df578cd78">More...</a><br /></td></tr>
<tr class="separator:af0c35f1d2d81adf4ba06b84df578cd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eed02898a13f56e0bc2a470c2f89af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad2eed02898a13f56e0bc2a470c2f89af">mergeAndAlignIdsWithOther</a> (<a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *other)</td></tr>
<tr class="memdesc:ad2eed02898a13f56e0bc2a470c2f89af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align the identifiers of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with <code>this</code>'s original identifiers appearing first followed by any of <code>other</code>'s identifiers that didn't appear in <code>this</code>.  <a href="#ad2eed02898a13f56e0bc2a470c2f89af">More...</a><br /></td></tr>
<tr class="separator:ad2eed02898a13f56e0bc2a470c2f89af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb1fae3bb100c4a3391e523712d2dba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a4fb1fae3bb100c4a3391e523712d2dba">areIdsAlignedWithOther</a> (const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a4fb1fae3bb100c4a3391e523712d2dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order.  <a href="#a4fb1fae3bb100c4a3391e523712d2dba">More...</a><br /></td></tr>
<tr class="separator:a4fb1fae3bb100c4a3391e523712d2dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacc473110655fc94f713fa3733f8e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#afacc473110655fc94f713fa3733f8e9e">clearAndCopyFrom</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other) override</td></tr>
<tr class="memdesc:afacc473110655fc94f713fa3733f8e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="An extension of FlatAffineConstraints in which dimensions and symbols can optionally be associated wi...">FlatAffineValueConstraints</a> with <code>other</code>.  <a href="#afacc473110655fc94f713fa3733f8e9e">More...</a><br /></td></tr>
<tr class="separator:afacc473110655fc94f713fa3733f8e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3896e7ab007a7bd1e8d1fb1fb098bdea">getValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a3896e7ab007a7bd1e8d1fb1fb098bdea">More...</a><br /></td></tr>
<tr class="separator:a3896e7ab007a7bd1e8d1fb1fb098bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e39afc73e0776e068eb7331bcb349c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5e39afc73e0776e068eb7331bcb349c7">hasValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a5e39afc73e0776e068eb7331bcb349c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a5e39afc73e0776e068eb7331bcb349c7">More...</a><br /></td></tr>
<tr class="separator:a5e39afc73e0776e068eb7331bcb349c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321a6a4ea45324a6c969a5b5062ec932"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a321a6a4ea45324a6c969a5b5062ec932">hasValues</a> () const</td></tr>
<tr class="memdesc:a321a6a4ea45324a6c969a5b5062ec932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if at least one identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a321a6a4ea45324a6c969a5b5062ec932">More...</a><br /></td></tr>
<tr class="separator:a321a6a4ea45324a6c969a5b5062ec932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccc790e216f3bbf7416308c04045094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a9ccc790e216f3bbf7416308c04045094">getValues</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="memdesc:a9ccc790e216f3bbf7416308c04045094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Values associated with identifiers in range [start, end).  <a href="#a9ccc790e216f3bbf7416308c04045094">More...</a><br /></td></tr>
<tr class="separator:a9ccc790e216f3bbf7416308c04045094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5177b199aa494103835274f72907a8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#af5177b199aa494103835274f72907a8b">getAllValues</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>) const</td></tr>
<tr class="separator:af5177b199aa494103835274f72907a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7998d8323c934c13a86769ca8fad877"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#ad7998d8323c934c13a86769ca8fad877">getMaybeValues</a> () const</td></tr>
<tr class="separator:ad7998d8323c934c13a86769ca8fad877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e61e7f65a2ddd3fb4dc389d1fcd4467"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a1e61e7f65a2ddd3fb4dc389d1fcd4467">getMaybeDimValues</a> () const</td></tr>
<tr class="separator:a1e61e7f65a2ddd3fb4dc389d1fcd4467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464901024f611db773f2def48443b8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a464901024f611db773f2def48443b8f8">getMaybeSymbolValues</a> () const</td></tr>
<tr class="separator:a464901024f611db773f2def48443b8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d108d7e10610afd56b9bc03598741f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a0d108d7e10610afd56b9bc03598741f9">getMaybeDimAndSymbolValues</a> () const</td></tr>
<tr class="separator:a0d108d7e10610afd56b9bc03598741f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5eccad1d331cf5cfb78bf1f08fda7224">setValue</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier.  <a href="#a5eccad1d331cf5cfb78bf1f08fda7224">More...</a><br /></td></tr>
<tr class="separator:a5eccad1d331cf5cfb78bf1f08fda7224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320c65d604a6089bb16894e4a9ee33bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a320c65d604a6089bb16894e4a9ee33bf">setValues</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a>)</td></tr>
<tr class="memdesc:a320c65d604a6089bb16894e4a9ee33bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Values associated with the identifiers in the range [start, end).  <a href="#a320c65d604a6089bb16894e4a9ee33bf">More...</a><br /></td></tr>
<tr class="separator:a320c65d604a6089bb16894e4a9ee33bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5333879b7e111caf2c3371c0d0745296"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a5333879b7e111caf2c3371c0d0745296">mergeSymbolIds</a> (<a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:a5333879b7e111caf2c3371c0d0745296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique.  <a href="#a5333879b7e111caf2c3371c0d0745296">More...</a><br /></td></tr>
<tr class="separator:a5333879b7e111caf2c3371c0d0745296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:ad696d4f93b157c44fec1e3965e850433 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad696d4f93b157c44fec1e3965e850433">FlatAffineConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals)</td></tr>
<tr class="memdesc:ad696d4f93b157c44fec1e3965e850433 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="classmlir_1_1FlatAffineConstraints.html#ad696d4f93b157c44fec1e3965e850433">More...</a><br /></td></tr>
<tr class="separator:ad696d4f93b157c44fec1e3965e850433 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac128caef8d1284314f3220982733a7df inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac128caef8d1284314f3220982733a7df">FlatAffineConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="memdesc:ac128caef8d1284314f3220982733a7df inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="classmlir_1_1FlatAffineConstraints.html#ac128caef8d1284314f3220982733a7df">More...</a><br /></td></tr>
<tr class="separator:ac128caef8d1284314f3220982733a7df inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04009cfc4f3c97dbff1cf9594c0f7c9a inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a04009cfc4f3c97dbff1cf9594c0f7c9a">FlatAffineConstraints</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a04009cfc4f3c97dbff1cf9594c0f7c9a inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#a04009cfc4f3c97dbff1cf9594c0f7c9a">More...</a><br /></td></tr>
<tr class="separator:a04009cfc4f3c97dbff1cf9594c0f7c9a inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8074122b77beb705d010169667ae9efe inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8074122b77beb705d010169667ae9efe">FlatAffineConstraints</a> (const <a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a> &amp;map)</td></tr>
<tr class="separator:a8074122b77beb705d010169667ae9efe inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948c10906e0c0a4ab77176a31035a73b inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a948c10906e0c0a4ab77176a31035a73b">~FlatAffineConstraints</a> ()=default</td></tr>
<tr class="separator:a948c10906e0c0a4ab77176a31035a73b inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ddc2ce92fc0297fbc8bfc62241c4472 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6ddc2ce92fc0297fbc8bfc62241c4472">isEmpty</a> () const</td></tr>
<tr class="memdesc:a6ddc2ce92fc0297fbc8bfc62241c4472 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for emptiness by performing variable elimination on all identifiers, running the GCD test on each equality constraint, and checking for invalid constraints.  <a href="classmlir_1_1FlatAffineConstraints.html#a6ddc2ce92fc0297fbc8bfc62241c4472">More...</a><br /></td></tr>
<tr class="separator:a6ddc2ce92fc0297fbc8bfc62241c4472 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af318337e58529a47cd9c9e38e11b3e67 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af318337e58529a47cd9c9e38e11b3e67">isEmptyByGCDTest</a> () const</td></tr>
<tr class="memdesc:af318337e58529a47cd9c9e38e11b3e67 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the GCD test on all equality constraints.  <a href="classmlir_1_1FlatAffineConstraints.html#af318337e58529a47cd9c9e38e11b3e67">More...</a><br /></td></tr>
<tr class="separator:af318337e58529a47cd9c9e38e11b3e67 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b4af0478ccc4117618d8f530e41bb inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aef2b4af0478ccc4117618d8f530e41bb">isIntegerEmpty</a> () const</td></tr>
<tr class="memdesc:aef2b4af0478ccc4117618d8f530e41bb inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set of constraints is found to have no solution, false if a solution exists.  <a href="classmlir_1_1FlatAffineConstraints.html#aef2b4af0478ccc4117618d8f530e41bb">More...</a><br /></td></tr>
<tr class="separator:aef2b4af0478ccc4117618d8f530e41bb inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ef7a710ab1ff16234a3e4ba01e1d7f inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab7ef7a710ab1ff16234a3e4ba01e1d7f">getBoundedDirections</a> () const</td></tr>
<tr class="memdesc:ab7ef7a710ab1ff16234a3e4ba01e1d7f inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix where each row is a vector along which the polytope is bounded.  <a href="classmlir_1_1FlatAffineConstraints.html#ab7ef7a710ab1ff16234a3e4ba01e1d7f">More...</a><br /></td></tr>
<tr class="separator:ab7ef7a710ab1ff16234a3e4ba01e1d7f inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068c098c9581e2b99d317a11fd0a3105 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a068c098c9581e2b99d317a11fd0a3105">findIntegerSample</a> () const</td></tr>
<tr class="memdesc:a068c098c9581e2b99d317a11fd0a3105 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an integer sample point satisfying the constraints using a branch and bound algorithm with generalized basis reduction, with some additional processing using <a class="el" href="classmlir_1_1Simplex.html">Simplex</a> for unbounded sets.  <a href="classmlir_1_1FlatAffineConstraints.html#a068c098c9581e2b99d317a11fd0a3105">More...</a><br /></td></tr>
<tr class="separator:a068c098c9581e2b99d317a11fd0a3105 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae447433822615a5748eb99dc75961579 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae447433822615a5748eb99dc75961579">containsPoint</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; point) const</td></tr>
<tr class="memdesc:ae447433822615a5748eb99dc75961579 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given point satisfies the constraints, or false otherwise.  <a href="classmlir_1_1FlatAffineConstraints.html#ae447433822615a5748eb99dc75961579">More...</a><br /></td></tr>
<tr class="separator:ae447433822615a5748eb99dc75961579 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95feac8d46e898c9afc6e0ea965ac62e inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a95feac8d46e898c9afc6e0ea965ac62e">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators, std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&gt; &amp;repr) const</td></tr>
<tr class="memdesc:a95feac8d46e898c9afc6e0ea965ac62e inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find pairs of inequalities identified by their position indices, using which an explicit representation for each local variable can be computed.  <a href="classmlir_1_1FlatAffineConstraints.html#a95feac8d46e898c9afc6e0ea965ac62e">More...</a><br /></td></tr>
<tr class="separator:a95feac8d46e898c9afc6e0ea965ac62e inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3874c61c1c0744d4b00241e280ff68eb inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a3874c61c1c0744d4b00241e280ff68eb">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; std::pair&lt; <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt;&gt;&gt; &amp;repr) const</td></tr>
<tr class="separator:a3874c61c1c0744d4b00241e280ff68eb inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac6b777c22096af2f6c331ccc16a282 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#adac6b777c22096af2f6c331ccc16a282">getLocalReprs</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; &amp;dividends, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a>, 4 &gt; &amp;denominators) const</td></tr>
<tr class="separator:adac6b777c22096af2f6c331ccc16a282 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0932fcc3e8ee32f1af944a1f33a9abc3 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a0932fcc3e8ee32f1af944a1f33a9abc3">clone</a> () const</td></tr>
<tr class="separator:a0932fcc3e8ee32f1af944a1f33a9abc3 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520de7a96a9cdf5130756e58a42e6371 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a520de7a96a9cdf5130756e58a42e6371">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap)</td></tr>
<tr class="memdesc:a520de7a96a9cdf5130756e58a42e6371 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map.  <a href="classmlir_1_1FlatAffineConstraints.html#a520de7a96a9cdf5130756e58a42e6371">More...</a><br /></td></tr>
<tr class="separator:a520de7a96a9cdf5130756e58a42e6371 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ebc66e64e3cd0f7eb89514664f786d inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af1ebc66e64e3cd0f7eb89514664f786d">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:af1ebc66e64e3cd0f7eb89514664f786d inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified identifier.  <a href="classmlir_1_1FlatAffineConstraints.html#af1ebc66e64e3cd0f7eb89514664f786d">More...</a><br /></td></tr>
<tr class="separator:af1ebc66e64e3cd0f7eb89514664f786d inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37e7bf9c07a76d9ea38b447d5c75742 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad37e7bf9c07a76d9ea38b447d5c75742">addBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; expr, int64_t <a class="el" href="InterfaceSupport_8h.html#a53ed1830bfcbea42b0e7b10281e03865">value</a>)</td></tr>
<tr class="memdesc:ad37e7bf9c07a76d9ea38b447d5c75742 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a constant bound for the specified expression.  <a href="classmlir_1_1FlatAffineConstraints.html#ad37e7bf9c07a76d9ea38b447d5c75742">More...</a><br /></td></tr>
<tr class="separator:ad37e7bf9c07a76d9ea38b447d5c75742 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ce04a3ec6c6baf9308f460ae14c751 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad9ce04a3ec6c6baf9308f460ae14c751">getAsIntegerSet</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:ad9ce04a3ec6c6baf9308f460ae14c751 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constraint system as an integer set.  <a href="classmlir_1_1FlatAffineConstraints.html#ad9ce04a3ec6c6baf9308f460ae14c751">More...</a><br /></td></tr>
<tr class="separator:ad9ce04a3ec6c6baf9308f460ae14c751 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fe40151ae13ca4d10c425937ff70f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27fe40151ae13ca4d10c425937ff70f2">getSliceBounds</a> (<a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *lbMaps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; *ubMaps)</td></tr>
<tr class="memdesc:a27fe40151ae13ca4d10c425937ff70f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the lower and upper bounds of the first <code>num</code> dimensional identifiers (starting at <code>offset</code>) as an affine map of the remaining identifiers (dimensional and symbolic).  <a href="classmlir_1_1FlatAffineConstraints.html#a27fe40151ae13ca4d10c425937ff70f2">More...</a><br /></td></tr>
<tr class="separator:a27fe40151ae13ca4d10c425937ff70f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d81cc0ca235dba7982f6cecc66f2506 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9d81cc0ca235dba7982f6cecc66f2506">addLocalFloorDiv</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; dividend, int64_t divisor)</td></tr>
<tr class="memdesc:a9d81cc0ca235dba7982f6cecc66f2506 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new local identifier as the floordiv of an affine function of other identifiers, the coefficients of which are provided in <code>dividend</code> and with respect to a positive constant <code>divisor</code>.  <a href="classmlir_1_1FlatAffineConstraints.html#a9d81cc0ca235dba7982f6cecc66f2506">More...</a><br /></td></tr>
<tr class="separator:a9d81cc0ca235dba7982f6cecc66f2506 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f95bfc66876ee75db55381eafbb8f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a15f95bfc66876ee75db55381eafbb8f2">composeMatchingMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other)</td></tr>
<tr class="memdesc:a15f95bfc66876ee75db55381eafbb8f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Composes an affine map whose dimensions and symbols match one to one with the dimensions and symbols of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#a15f95bfc66876ee75db55381eafbb8f2">More...</a><br /></td></tr>
<tr class="separator:a15f95bfc66876ee75db55381eafbb8f2 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d1457dc3d54274c1519c6553be921d inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a63d1457dc3d54274c1519c6553be921d">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:a63d1457dc3d54274c1519c6553be921d inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Projects out (aka eliminates) <code>num</code> identifiers starting at position <code>pos</code>.  <a href="classmlir_1_1FlatAffineConstraints.html#a63d1457dc3d54274c1519c6553be921d">More...</a><br /></td></tr>
<tr class="separator:a63d1457dc3d54274c1519c6553be921d inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3d0c1b0bad5d54e4b5f91910c52503 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8c3d0c1b0bad5d54e4b5f91910c52503">projectOut</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a8c3d0c1b0bad5d54e4b5f91910c52503 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c88dcf47e95f1973d1f2bb5f40979e5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a1c88dcf47e95f1973d1f2bb5f40979e5">setAndEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; values)</td></tr>
<tr class="memdesc:a1c88dcf47e95f1973d1f2bb5f40979e5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <code>values.size()</code> identifiers starting at <code>po</code>s to the specified values and removes them.  <a href="classmlir_1_1FlatAffineConstraints.html#a1c88dcf47e95f1973d1f2bb5f40979e5">More...</a><br /></td></tr>
<tr class="separator:a1c88dcf47e95f1973d1f2bb5f40979e5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4924b4c54d6823f8e52933ca960c1ff inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad4924b4c54d6823f8e52933ca960c1ff">setDimSymbolSeparation</a> (<a class="el" href="classunsigned.html">unsigned</a> newSymbolCount)</td></tr>
<tr class="memdesc:ad4924b4c54d6823f8e52933ca960c1ff inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the partition between dimensions and symbols.  <a href="classmlir_1_1FlatAffineConstraints.html#ad4924b4c54d6823f8e52933ca960c1ff">More...</a><br /></td></tr>
<tr class="separator:ad4924b4c54d6823f8e52933ca960c1ff inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e1041e7db596d628253f1d8d7c8222 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a00e1041e7db596d628253f1d8d7c8222">constantFoldId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a00e1041e7db596d628253f1d8d7c8222 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to fold the specified identifier to a constant using a trivial equality detection; if successful, the constant is substituted for the identifier everywhere in the constraint system and then removed from the system.  <a href="classmlir_1_1FlatAffineConstraints.html#a00e1041e7db596d628253f1d8d7c8222">More...</a><br /></td></tr>
<tr class="separator:a00e1041e7db596d628253f1d8d7c8222 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b4c81a969b09cf5c4bc723cda93d5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ad67b4c81a969b09cf5c4bc723cda93d5">constantFoldIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:ad67b4c81a969b09cf5c4bc723cda93d5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method calls <code>constantFoldId</code> for the specified range of identifiers, <code>num</code> identifiers starting at position <code>pos</code>.  <a href="classmlir_1_1FlatAffineConstraints.html#ad67b4c81a969b09cf5c4bc723cda93d5">More...</a><br /></td></tr>
<tr class="separator:ad67b4c81a969b09cf5c4bc723cda93d5 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8348eba3bd5c81db503336ae2ebfc inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afeb8348eba3bd5c81db503336ae2ebfc">unionBoundingBox</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:afeb8348eba3bd5c81db503336ae2ebfc inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially.  <a href="classmlir_1_1FlatAffineConstraints.html#afeb8348eba3bd5c81db503336ae2ebfc">More...</a><br /></td></tr>
<tr class="separator:afeb8348eba3bd5c81db503336ae2ebfc inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee472dcf0f37342df02e5af53b7aa45 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#acee472dcf0f37342df02e5af53b7aa45">getConstantBoundOnDimSize</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *lb=nullptr, int64_t *boundFloorDivisor=nullptr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *ub=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minLbPos=nullptr, <a class="el" href="classunsigned.html">unsigned</a> *minUbPos=nullptr) const</td></tr>
<tr class="memdesc:acee472dcf0f37342df02e5af53b7aa45 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest known constant bound for the extent of the specified identifier (pos^th), i.e., the smallest known constant that is greater than or equal to 'exclusive upper bound' - 'lower bound' of the identifier.  <a href="classmlir_1_1FlatAffineConstraints.html#acee472dcf0f37342df02e5af53b7aa45">More...</a><br /></td></tr>
<tr class="separator:acee472dcf0f37342df02e5af53b7aa45 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaee57edfdfaaff4c7a33c52ddbb94ca inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aeaee57edfdfaaff4c7a33c52ddbb94ca">getConstantBound</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:aeaee57edfdfaaff4c7a33c52ddbb94ca inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant bound for the pos^th identifier if there is one; None otherwise.  <a href="classmlir_1_1FlatAffineConstraints.html#aeaee57edfdfaaff4c7a33c52ddbb94ca">More...</a><br /></td></tr>
<tr class="separator:aeaee57edfdfaaff4c7a33c52ddbb94ca inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cdbe1cff606a9b364e734ca09dc52 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aad0cdbe1cff606a9b364e734ca09dc52">getLowerAndUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> offset, <a class="el" href="classunsigned.html">unsigned</a> num, <a class="el" href="classunsigned.html">unsigned</a> symStartPos, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context) const</td></tr>
<tr class="memdesc:aad0cdbe1cff606a9b364e734ca09dc52 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the lower and upper bound of the <code>offset</code> + <code>pos</code>th identifier treating [0, offset) U [offset + num, symStartPos) as dimensions and [symStartPos, getNumDimAndSymbolIds) as symbols, and <code>pos</code> lies in [0, num).  <a href="classmlir_1_1FlatAffineConstraints.html#aad0cdbe1cff606a9b364e734ca09dc52">More...</a><br /></td></tr>
<tr class="separator:aad0cdbe1cff606a9b364e734ca09dc52 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9dbede371ec7b45452b41c7ecc7045e inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac9dbede371ec7b45452b41c7ecc7045e">removeIndependentConstraints</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num)</td></tr>
<tr class="memdesc:ac9dbede371ec7b45452b41c7ecc7045e inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes constraints that are independent of (i.e., do not have a coefficient) identifiers in the range [pos, pos + num).  <a href="classmlir_1_1FlatAffineConstraints.html#ac9dbede371ec7b45452b41c7ecc7045e">More...</a><br /></td></tr>
<tr class="separator:ac9dbede371ec7b45452b41c7ecc7045e inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa635e50de116843fba9c4d6213ce14c inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#afa635e50de116843fba9c4d6213ce14c">isHyperRectangular</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num) const</td></tr>
<tr class="memdesc:afa635e50de116843fba9c4d6213ce14c inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the set can be trivially detected as being hyper-rectangular on the specified contiguous set of identifiers.  <a href="classmlir_1_1FlatAffineConstraints.html#afa635e50de116843fba9c4d6213ce14c">More...</a><br /></td></tr>
<tr class="separator:afa635e50de116843fba9c4d6213ce14c inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a710d4a8812b2e76eb3908a5767dac inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ab3a710d4a8812b2e76eb3908a5767dac">removeTrivialRedundancy</a> ()</td></tr>
<tr class="memdesc:ab3a710d4a8812b2e76eb3908a5767dac inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate constraints, trivially true constraints, and constraints that can be detected as redundant as a result of differing only in their constant term part.  <a href="classmlir_1_1FlatAffineConstraints.html#ab3a710d4a8812b2e76eb3908a5767dac">More...</a><br /></td></tr>
<tr class="separator:ab3a710d4a8812b2e76eb3908a5767dac inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b9abcf1ae4683b7ed214125d4d05c8 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a60b9abcf1ae4683b7ed214125d4d05c8">removeRedundantInequalities</a> ()</td></tr>
<tr class="memdesc:a60b9abcf1ae4683b7ed214125d4d05c8 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more expensive check than <code>removeTrivialRedundancy</code> to detect redundant inequalities.  <a href="classmlir_1_1FlatAffineConstraints.html#a60b9abcf1ae4683b7ed214125d4d05c8">More...</a><br /></td></tr>
<tr class="separator:a60b9abcf1ae4683b7ed214125d4d05c8 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d4b723904aafdfe34740b766c78789 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae9d4b723904aafdfe34740b766c78789">removeRedundantConstraints</a> ()</td></tr>
<tr class="memdesc:ae9d4b723904aafdfe34740b766c78789 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes redundant constraints using <a class="el" href="classmlir_1_1Simplex.html">Simplex</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#ae9d4b723904aafdfe34740b766c78789">More...</a><br /></td></tr>
<tr class="separator:ae9d4b723904aafdfe34740b766c78789 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e9d04e72add0e58c934cae62413ac7 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a27e9d04e72add0e58c934cae62413ac7">convertDimToLocal</a> (<a class="el" href="classunsigned.html">unsigned</a> dimStart, <a class="el" href="classunsigned.html">unsigned</a> dimLimit)</td></tr>
<tr class="memdesc:a27e9d04e72add0e58c934cae62413ac7 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts identifiers in the column range [idStart, idLimit) to local variables.  <a href="classmlir_1_1FlatAffineConstraints.html#a27e9d04e72add0e58c934cae62413ac7">More...</a><br /></td></tr>
<tr class="separator:a27e9d04e72add0e58c934cae62413ac7 inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b82371642e5a1db0e6125f07b3713f inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ae0b82371642e5a1db0e6125f07b3713f">mergeLocalIds</a> (<a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;other)</td></tr>
<tr class="memdesc:ae0b82371642e5a1db0e6125f07b3713f inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds additional local ids to the sets such that they both have the union of the local ids in each set, without changing the set of points that lie in <code>this</code> and <code>other</code>.  <a href="classmlir_1_1FlatAffineConstraints.html#ae0b82371642e5a1db0e6125f07b3713f">More...</a><br /></td></tr>
<tr class="separator:ae0b82371642e5a1db0e6125f07b3713f inherit pub_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:a3501f10308fee916c3f2d899f3994a06 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a3501f10308fee916c3f2d899f3994a06">IntegerPolyhedron</a> (<a class="el" href="classunsigned.html">unsigned</a> numReservedInequalities, <a class="el" href="classunsigned.html">unsigned</a> numReservedEqualities, <a class="el" href="classunsigned.html">unsigned</a> numReservedCols, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>, <a class="el" href="classunsigned.html">unsigned</a> numLocals)</td></tr>
<tr class="memdesc:a3501f10308fee916c3f2d899f3994a06 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system reserving memory for the specified number of constraints and identifiers.  <a href="classmlir_1_1IntegerPolyhedron.html#a3501f10308fee916c3f2d899f3994a06">More...</a><br /></td></tr>
<tr class="separator:a3501f10308fee916c3f2d899f3994a06 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1586990a764768bba6f547106d792485 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a1586990a764768bba6f547106d792485">IntegerPolyhedron</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="memdesc:a1586990a764768bba6f547106d792485 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a constraint system with the specified number of dimensions and symbols.  <a href="classmlir_1_1IntegerPolyhedron.html#a1586990a764768bba6f547106d792485">More...</a><br /></td></tr>
<tr class="separator:a1586990a764768bba6f547106d792485 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bac06d2396336edc10f842b3123d151 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a4bac06d2396336edc10f842b3123d151">~IntegerPolyhedron</a> ()=default</td></tr>
<tr class="separator:a4bac06d2396336edc10f842b3123d151 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ae519080bf303b244bde7d9d3b57ee13c">clone</a> () const</td></tr>
<tr class="separator:ae519080bf303b244bde7d9d3b57ee13c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d0d8adfef18e063b082d99cef8d540 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac9d0d8adfef18e063b082d99cef8d540">reset</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0, <a class="el" href="classunsigned.html">unsigned</a> numLocals=0)</td></tr>
<tr class="separator:ac9d0d8adfef18e063b082d99cef8d540 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9360ca3e1c7cf83b55e8902186df85fd inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a9360ca3e1c7cf83b55e8902186df85fd">append</a> (const <a class="el" href="classmlir_1_1IntegerPolyhedron.html">IntegerPolyhedron</a> &amp;other)</td></tr>
<tr class="memdesc:a9360ca3e1c7cf83b55e8902186df85fd inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends constraints from <code>other</code> into <code>this</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#a9360ca3e1c7cf83b55e8902186df85fd">More...</a><br /></td></tr>
<tr class="separator:a9360ca3e1c7cf83b55e8902186df85fd inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44beaa9fcdf33df89fd24236d984c3c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ab44beaa9fcdf33df89fd24236d984c3c">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:ab44beaa9fcdf33df89fd24236d984c3c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified equality row and column.  <a href="classmlir_1_1IntegerPolyhedron.html#ab44beaa9fcdf33df89fd24236d984c3c">More...</a><br /></td></tr>
<tr class="separator:ab44beaa9fcdf33df89fd24236d984c3c inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7845afe41fe57beaef7929df5ab064ff inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7845afe41fe57beaef7929df5ab064ff">atEq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:a7845afe41fe57beaef7929df5ab064ff inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd415defcb46be0860dc9d41bc72219b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#afd415defcb46be0860dc9d41bc72219b">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>) const</td></tr>
<tr class="memdesc:afd415defcb46be0860dc9d41bc72219b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value at the specified inequality row and column.  <a href="classmlir_1_1IntegerPolyhedron.html#afd415defcb46be0860dc9d41bc72219b">More...</a><br /></td></tr>
<tr class="separator:afd415defcb46be0860dc9d41bc72219b inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20d60d4491633ecd8ef7bf9c018dc2a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">int64_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad20d60d4491633ecd8ef7bf9c018dc2a">atIneq</a> (<a class="el" href="classunsigned.html">unsigned</a> i, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="unionj.html">j</a>)</td></tr>
<tr class="separator:ad20d60d4491633ecd8ef7bf9c018dc2a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6729d0a4f3d7cf524c9d3182697af910 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a6729d0a4f3d7cf524c9d3182697af910">getNumConstraints</a> () const</td></tr>
<tr class="separator:a6729d0a4f3d7cf524c9d3182697af910 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325cdb95f80ea7f700b1098f96c4eeb2 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a325cdb95f80ea7f700b1098f96c4eeb2">getNumIds</a> () const</td></tr>
<tr class="separator:a325cdb95f80ea7f700b1098f96c4eeb2 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c82b907b69e86a74175af3b3656e0d9 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7c82b907b69e86a74175af3b3656e0d9">getNumDimIds</a> () const</td></tr>
<tr class="separator:a7c82b907b69e86a74175af3b3656e0d9 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e47e5e34d75aaae295fe38453927da inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a75e47e5e34d75aaae295fe38453927da">getNumSymbolIds</a> () const</td></tr>
<tr class="separator:a75e47e5e34d75aaae295fe38453927da inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585b64806cefe23cbbd72f8260c69f83 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a585b64806cefe23cbbd72f8260c69f83">getNumDimAndSymbolIds</a> () const</td></tr>
<tr class="separator:a585b64806cefe23cbbd72f8260c69f83 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6b390d072fba4f1078ab5bfcf3a9b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a4e6b390d072fba4f1078ab5bfcf3a9b7">getNumLocalIds</a> () const</td></tr>
<tr class="separator:a4e6b390d072fba4f1078ab5bfcf3a9b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489082b1b320a22b53e6c07dd6a1309 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7489082b1b320a22b53e6c07dd6a1309">getNumCols</a> () const</td></tr>
<tr class="memdesc:a7489082b1b320a22b53e6c07dd6a1309 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the constraint system.  <a href="classmlir_1_1IntegerPolyhedron.html#a7489082b1b320a22b53e6c07dd6a1309">More...</a><br /></td></tr>
<tr class="separator:a7489082b1b320a22b53e6c07dd6a1309 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7957b4460801b6a74789e4de7ab7e8b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7957b4460801b6a74789e4de7ab7e8b7">getNumEqualities</a> () const</td></tr>
<tr class="separator:a7957b4460801b6a74789e4de7ab7e8b7 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92467fbc77816a48e7f3b8566228cb5a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a92467fbc77816a48e7f3b8566228cb5a">getNumInequalities</a> () const</td></tr>
<tr class="separator:a92467fbc77816a48e7f3b8566228cb5a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4aee9eb7cf477eb735f8ad47a2721fe inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ae4aee9eb7cf477eb735f8ad47a2721fe">getNumReservedEqualities</a> () const</td></tr>
<tr class="separator:ae4aee9eb7cf477eb735f8ad47a2721fe inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed465b2e8cd89724f098f1ceca052fef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aed465b2e8cd89724f098f1ceca052fef">getNumReservedInequalities</a> () const</td></tr>
<tr class="separator:aed465b2e8cd89724f098f1ceca052fef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef5b6cf6f461b4e1c15b365c284ace1 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#abef5b6cf6f461b4e1c15b365c284ace1">getEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:abef5b6cf6f461b4e1c15b365c284ace1 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86817d70ff79e0f33b7c8291d17f043f inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a86817d70ff79e0f33b7c8291d17f043f">getInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="separator:a86817d70ff79e0f33b7c8291d17f043f inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176f55575a99f416b3d3493c8450b032 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a176f55575a99f416b3d3493c8450b032">insertDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:a176f55575a99f416b3d3493c8450b032 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert <code>num</code> identifiers of the specified kind at position <code>pos</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#a176f55575a99f416b3d3493c8450b032">More...</a><br /></td></tr>
<tr class="separator:a176f55575a99f416b3d3493c8450b032 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d499b36bfd9e8fffb2e00493501ce inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aaa5d499b36bfd9e8fffb2e00493501ce">insertSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:aaa5d499b36bfd9e8fffb2e00493501ce inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c796331c696fff5d5873394e43415d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a00c796331c696fff5d5873394e43415d">insertLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:a00c796331c696fff5d5873394e43415d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398c3ef2afff3bf90c2d36686de1f5a4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a398c3ef2afff3bf90c2d36686de1f5a4">appendDimId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="memdesc:a398c3ef2afff3bf90c2d36686de1f5a4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append <code>num</code> identifiers of the specified kind after the last identifier.  <a href="classmlir_1_1IntegerPolyhedron.html#a398c3ef2afff3bf90c2d36686de1f5a4">More...</a><br /></td></tr>
<tr class="separator:a398c3ef2afff3bf90c2d36686de1f5a4 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7368fdf3751bcf749fef64c2aaa8b6d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ad7368fdf3751bcf749fef64c2aaa8b6d">appendSymbolId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:ad7368fdf3751bcf749fef64c2aaa8b6d inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40399291a13818f59bccdfa6836f129 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac40399291a13818f59bccdfa6836f129">appendLocalId</a> (<a class="el" href="classunsigned.html">unsigned</a> num=1)</td></tr>
<tr class="separator:ac40399291a13818f59bccdfa6836f129 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4807617a443edaece02bad5624a90cc inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac4807617a443edaece02bad5624a90cc">addInequality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inEq)</td></tr>
<tr class="memdesc:ac4807617a443edaece02bad5624a90cc inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an inequality (&gt;= 0) from the coefficients specified in <code>inEq</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#ac4807617a443edaece02bad5624a90cc">More...</a><br /></td></tr>
<tr class="separator:ac4807617a443edaece02bad5624a90cc inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d9dc5cc6ab049a0039895e757a89ac inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac1d9dc5cc6ab049a0039895e757a89ac">addEquality</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq)</td></tr>
<tr class="memdesc:ac1d9dc5cc6ab049a0039895e757a89ac inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an equality from the coefficients specified in <code>eq</code>.  <a href="classmlir_1_1IntegerPolyhedron.html#ac1d9dc5cc6ab049a0039895e757a89ac">More...</a><br /></td></tr>
<tr class="separator:ac1d9dc5cc6ab049a0039895e757a89ac inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601403d3007ad399ccb10c2900a2cda0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a601403d3007ad399ccb10c2900a2cda0">removeId</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a601403d3007ad399ccb10c2900a2cda0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers of the specified kind with the specified pos (or within the specified range) from the system.  <a href="classmlir_1_1IntegerPolyhedron.html#a601403d3007ad399ccb10c2900a2cda0">More...</a><br /></td></tr>
<tr class="separator:a601403d3007ad399ccb10c2900a2cda0 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3531b899e53eb59cf8c493869ddd33 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7c3531b899e53eb59cf8c493869ddd33">removeIdRange</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind, <a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit)</td></tr>
<tr class="separator:a7c3531b899e53eb59cf8c493869ddd33 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0057caf049402c9b336bda7fabd604ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0057caf049402c9b336bda7fabd604ee">removeId</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a0057caf049402c9b336bda7fabd604ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified identifier from the system.  <a href="classmlir_1_1IntegerPolyhedron.html#a0057caf049402c9b336bda7fabd604ee">More...</a><br /></td></tr>
<tr class="separator:a0057caf049402c9b336bda7fabd604ee inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaae4a8339cc069d3674de26acb60e7a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#abaae4a8339cc069d3674de26acb60e7a">removeEquality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:abaae4a8339cc069d3674de26acb60e7a inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a47e2c94aa9c20ced486fac1ec7f7ef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a2a47e2c94aa9c20ced486fac1ec7f7ef">removeInequality</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="separator:a2a47e2c94aa9c20ced486fac1ec7f7ef inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267749ba42f9a0290f5f337eb02d8799 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a267749ba42f9a0290f5f337eb02d8799">removeEqualityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="memdesc:a267749ba42f9a0290f5f337eb02d8799 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the (in)equalities at positions [start, end).  <a href="classmlir_1_1IntegerPolyhedron.html#a267749ba42f9a0290f5f337eb02d8799">More...</a><br /></td></tr>
<tr class="separator:a267749ba42f9a0290f5f337eb02d8799 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210bbd3864400b3eb4921e912bec915e inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a210bbd3864400b3eb4921e912bec915e">removeInequalityRange</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> end)</td></tr>
<tr class="separator:a210bbd3864400b3eb4921e912bec915e inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630d628b81e01098fbd05a3c0be47b34 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a630d628b81e01098fbd05a3c0be47b34">clearConstraints</a> ()</td></tr>
<tr class="memdesc:a630d628b81e01098fbd05a3c0be47b34 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all equalities and inequalities.  <a href="classmlir_1_1IntegerPolyhedron.html#a630d628b81e01098fbd05a3c0be47b34">More...</a><br /></td></tr>
<tr class="separator:a630d628b81e01098fbd05a3c0be47b34 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132c1a20471286db9060978b217def86 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a132c1a20471286db9060978b217def86">getLowerAndUpperBoundIndices</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *lbIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *ubIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *eqIndices=nullptr, <a class="el" href="classunsigned.html">unsigned</a> offset=0, <a class="el" href="classunsigned.html">unsigned</a> num=0) const</td></tr>
<tr class="memdesc:a132c1a20471286db9060978b217def86 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather positions of all lower and upper bounds of the identifier at <code>pos</code>, and optionally any equalities on it.  <a href="classmlir_1_1IntegerPolyhedron.html#a132c1a20471286db9060978b217def86">More...</a><br /></td></tr>
<tr class="separator:a132c1a20471286db9060978b217def86 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb075bff7cc53c3fd8108b962685e879 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#afb075bff7cc53c3fd8108b962685e879">print</a> (raw_ostream &amp;os) const</td></tr>
<tr class="separator:afb075bff7cc53c3fd8108b962685e879 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e2b93ee707f8d49c423f96b10292c79 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a4e2b93ee707f8d49c423f96b10292c79">dump</a> () const</td></tr>
<tr class="separator:a4e2b93ee707f8d49c423f96b10292c79 inherit pub_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acfee23f39d31078e69df752b973f53b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#acfee23f39d31078e69df752b973f53b6">getHyperrectangular</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ivs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs)</td></tr>
<tr class="separator:acfee23f39d31078e69df752b973f53b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75831f7477271eec30108f8c58a2f2d0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a75831f7477271eec30108f8c58a2f2d0">classof</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst)</td></tr>
<tr class="separator:a75831f7477271eec30108f8c58a2f2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:abe0c6f1821da05edc091e82d187e0e10 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#abe0c6f1821da05edc091e82d187e0e10">getUniverse</a> (<a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a>=0, <a class="el" href="classunsigned.html">unsigned</a> <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a>=0)</td></tr>
<tr class="memdesc:abe0c6f1821da05edc091e82d187e0e10 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a system with no constraints, i.e., one which is satisfied by all points.  <a href="classmlir_1_1FlatAffineConstraints.html#abe0c6f1821da05edc091e82d187e0e10">More...</a><br /></td></tr>
<tr class="separator:abe0c6f1821da05edc091e82d187e0e10 inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353de0786de4cb7459611d4219ba0bcd inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a353de0786de4cb7459611d4219ba0bcd">classof</a> (const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst)</td></tr>
<tr class="separator:a353de0786de4cb7459611d4219ba0bcd inherit pub_static_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3202cddcf31d0798de72cac6742248b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a3202cddcf31d0798de72cac6742248b0">hasConsistentState</a> () const override</td></tr>
<tr class="memdesc:a3202cddcf31d0798de72cac6742248b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise.  <a href="#a3202cddcf31d0798de72cac6742248b0">More...</a><br /></td></tr>
<tr class="separator:a3202cddcf31d0798de72cac6742248b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b415d11d42c0a1e02bc2c35833d3a2d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2b415d11d42c0a1e02bc2c35833d3a2d">removeIdRange</a> (<a class="el" href="classunsigned.html">unsigned</a> idStart, <a class="el" href="classunsigned.html">unsigned</a> idLimit) override</td></tr>
<tr class="memdesc:a2b415d11d42c0a1e02bc2c35833d3a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed.  <a href="#a2b415d11d42c0a1e02bc2c35833d3a2d">More...</a><br /></td></tr>
<tr class="separator:a2b415d11d42c0a1e02bc2c35833d3a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b3ca6765edfa5677b1b23130e0187c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a30b3ca6765edfa5677b1b23130e0187c">fourierMotzkinEliminate</a> (<a class="el" href="classunsigned.html">unsigned</a> pos, bool darkShadow=false, bool *isResultIntegerExact=nullptr) override</td></tr>
<tr class="memdesc:a30b3ca6765edfa5677b1b23130e0187c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier.  <a href="#a30b3ca6765edfa5677b1b23130e0187c">More...</a><br /></td></tr>
<tr class="separator:a30b3ca6765edfa5677b1b23130e0187c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:a463bb136705774c5730444a1f0b48274 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a463bb136705774c5730444a1f0b48274">hasInvalidConstraint</a> () const</td></tr>
<tr class="memdesc:a463bb136705774c5730444a1f0b48274 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks all rows of equality/inequality constraints for trivial contradictions (for example: 1 == 0, 0 &gt;= 1), which may have surfaced after elimination.  <a href="classmlir_1_1FlatAffineConstraints.html#a463bb136705774c5730444a1f0b48274">More...</a><br /></td></tr>
<tr class="separator:a463bb136705774c5730444a1f0b48274 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d2dbd6016eb6489a8bea183064194d inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memTemplParams" colspan="2">template&lt;bool isLower&gt; </td></tr>
<tr class="memitem:a48d2dbd6016eb6489a8bea183064194d inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a48d2dbd6016eb6489a8bea183064194d">computeConstantLowerOrUpperBound</a> (<a class="el" href="classunsigned.html">unsigned</a> pos)</td></tr>
<tr class="memdesc:a48d2dbd6016eb6489a8bea183064194d inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant lower bound bound if isLower is true, and the upper bound if isLower is false.  <a href="classmlir_1_1FlatAffineConstraints.html#a48d2dbd6016eb6489a8bea183064194d">More...</a><br /></td></tr>
<tr class="separator:a48d2dbd6016eb6489a8bea183064194d inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c97661a1c86284a9102a06018c7292 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a38c97661a1c86284a9102a06018c7292">flattenAlignedMapAndMergeLocals</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs)</td></tr>
<tr class="memdesc:a38c97661a1c86284a9102a06018c7292 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map that is aligned with this constraint system:  <a href="classmlir_1_1FlatAffineConstraints.html#a38c97661a1c86284a9102a06018c7292">More...</a><br /></td></tr>
<tr class="separator:a38c97661a1c86284a9102a06018c7292 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881e2217448214b13d07e90b0b53bc0c inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a881e2217448214b13d07e90b0b53bc0c">gaussianEliminateId</a> (<a class="el" href="classunsigned.html">unsigned</a> position)</td></tr>
<tr class="memdesc:a881e2217448214b13d07e90b0b53bc0c inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates a single identifier at <code>position</code> from equality and inequality constraints.  <a href="classmlir_1_1FlatAffineConstraints.html#a881e2217448214b13d07e90b0b53bc0c">More...</a><br /></td></tr>
<tr class="separator:a881e2217448214b13d07e90b0b53bc0c inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9208d76671184c970f66b656b3a5879 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#af9208d76671184c970f66b656b3a5879">removeRedundantLocalVars</a> ()</td></tr>
<tr class="memdesc:af9208d76671184c970f66b656b3a5879 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes local variables using equalities.  <a href="classmlir_1_1FlatAffineConstraints.html#af9208d76671184c970f66b656b3a5879">More...</a><br /></td></tr>
<tr class="separator:af9208d76671184c970f66b656b3a5879 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac976d9ff1b446d2c09838299bf465d4 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#aac976d9ff1b446d2c09838299bf465d4">gaussianEliminateIds</a> (<a class="el" href="classunsigned.html">unsigned</a> posStart, <a class="el" href="classunsigned.html">unsigned</a> posLimit)</td></tr>
<tr class="memdesc:aac976d9ff1b446d2c09838299bf465d4 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eliminates identifiers from equality and inequality constraints in column range [posStart, posLimit).  <a href="classmlir_1_1FlatAffineConstraints.html#aac976d9ff1b446d2c09838299bf465d4">More...</a><br /></td></tr>
<tr class="separator:aac976d9ff1b446d2c09838299bf465d4 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9131602623a80474f09f4c556a72c2fa inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a9131602623a80474f09f4c556a72c2fa">gcdTightenInequalities</a> ()</td></tr>
<tr class="memdesc:a9131602623a80474f09f4c556a72c2fa inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tightens inequalities given that we are dealing with integer spaces.  <a href="classmlir_1_1FlatAffineConstraints.html#a9131602623a80474f09f4c556a72c2fa">More...</a><br /></td></tr>
<tr class="separator:a9131602623a80474f09f4c556a72c2fa inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72473a5174d309b4dca1dba327ff901e inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a72473a5174d309b4dca1dba327ff901e">normalizeConstraintsByGCD</a> ()</td></tr>
<tr class="memdesc:a72473a5174d309b4dca1dba327ff901e inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalized each constraints by the GCD of its coefficients.  <a href="classmlir_1_1FlatAffineConstraints.html#a72473a5174d309b4dca1dba327ff901e">More...</a><br /></td></tr>
<tr class="separator:a72473a5174d309b4dca1dba327ff901e inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904bd3d7c7fd54eb130c13cc13147a3c inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a904bd3d7c7fd54eb130c13cc13147a3c">findConstraintWithNonZeroAt</a> (<a class="el" href="classunsigned.html">unsigned</a> colIdx, bool isEq, <a class="el" href="classunsigned.html">unsigned</a> *rowIdx) const</td></tr>
<tr class="memdesc:a904bd3d7c7fd54eb130c13cc13147a3c inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a constraint with a non-zero coefficient at <code>colIdx</code> in equality (isEq=true) or inequality (isEq=false) constraints.  <a href="classmlir_1_1FlatAffineConstraints.html#a904bd3d7c7fd54eb130c13cc13147a3c">More...</a><br /></td></tr>
<tr class="separator:a904bd3d7c7fd54eb130c13cc13147a3c inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d42857544d9b9b173cea788a17e6c0 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a70d42857544d9b9b173cea788a17e6c0">isColZero</a> (<a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a70d42857544d9b9b173cea788a17e6c0 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pos^th column is all zero for both inequalities and equalities.  <a href="classmlir_1_1FlatAffineConstraints.html#a70d42857544d9b9b173cea788a17e6c0">More...</a><br /></td></tr>
<tr class="separator:a70d42857544d9b9b173cea788a17e6c0 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12923f47851694f80045567e8d2c27c7 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a12923f47851694f80045567e8d2c27c7">printSpace</a> (raw_ostream &amp;os) const override</td></tr>
<tr class="memdesc:a12923f47851694f80045567e8d2c27c7 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the number of constraints, dimensions, symbols and locals in the <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#a12923f47851694f80045567e8d2c27c7">More...</a><br /></td></tr>
<tr class="separator:a12923f47851694f80045567e8d2c27c7 inherit pro_methods_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:a8329cea65520ec9250d69774587b9278 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a8329cea65520ec9250d69774587b9278">getIdKindOffset</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind) const</td></tr>
<tr class="memdesc:a8329cea65520ec9250d69774587b9278 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index at which the specified kind of id starts.  <a href="classmlir_1_1IntegerPolyhedron.html#a8329cea65520ec9250d69774587b9278">More...</a><br /></td></tr>
<tr class="separator:a8329cea65520ec9250d69774587b9278 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae8df118e423070fca2e7474cb46dc3 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#afae8df118e423070fca2e7474cb46dc3">getNumIdKind</a> (<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> kind) const</td></tr>
<tr class="memdesc:afae8df118e423070fca2e7474cb46dc3 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of ids of the specified kind.  <a href="classmlir_1_1IntegerPolyhedron.html#afae8df118e423070fca2e7474cb46dc3">More...</a><br /></td></tr>
<tr class="separator:afae8df118e423070fca2e7474cb46dc3 inherit pro_methods_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2662045a8d845c7cf9aa9516af6ea914"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html#a2662045a8d845c7cf9aa9516af6ea914">values</a></td></tr>
<tr class="memdesc:a2662045a8d845c7cf9aa9516af6ea914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values corresponding to the (column) identifiers of this constraint system appearing in the order the identifiers correspond to columns.  <a href="#a2662045a8d845c7cf9aa9516af6ea914">More...</a><br /></td></tr>
<tr class="separator:a2662045a8d845c7cf9aa9516af6ea914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:ac147d7a4f5baaf408a7c70f026a4355b inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#ac147d7a4f5baaf408a7c70f026a4355b">numIds</a></td></tr>
<tr class="memdesc:ac147d7a4f5baaf408a7c70f026a4355b inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of identifiers.  <a href="classmlir_1_1IntegerPolyhedron.html#ac147d7a4f5baaf408a7c70f026a4355b">More...</a><br /></td></tr>
<tr class="separator:ac147d7a4f5baaf408a7c70f026a4355b inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825f347cefc5dd82d88ab77e4b885638 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">numDims</a></td></tr>
<tr class="memdesc:a825f347cefc5dd82d88ab77e4b885638 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of identifiers corresponding to real dimensions.  <a href="classmlir_1_1IntegerPolyhedron.html#a825f347cefc5dd82d88ab77e4b885638">More...</a><br /></td></tr>
<tr class="separator:a825f347cefc5dd82d88ab77e4b885638 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782e4532eead025a6922187706bdda18 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">numSymbols</a></td></tr>
<tr class="memdesc:a782e4532eead025a6922187706bdda18 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of identifiers corresponding to symbols (unknown but constant for analysis).  <a href="classmlir_1_1IntegerPolyhedron.html#a782e4532eead025a6922187706bdda18">More...</a><br /></td></tr>
<tr class="separator:a782e4532eead025a6922187706bdda18 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74db4f4a7eda57e3ac5c079403a60f inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a7a74db4f4a7eda57e3ac5c079403a60f">equalities</a></td></tr>
<tr class="memdesc:a7a74db4f4a7eda57e3ac5c079403a60f inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine equalities (in == 0 form).  <a href="classmlir_1_1IntegerPolyhedron.html#a7a74db4f4a7eda57e3ac5c079403a60f">More...</a><br /></td></tr>
<tr class="separator:a7a74db4f4a7eda57e3ac5c079403a60f inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6b46b43e6b951daab2ac2cbfbf3da8 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#aec6b46b43e6b951daab2ac2cbfbf3da8">inequalities</a></td></tr>
<tr class="memdesc:aec6b46b43e6b951daab2ac2cbfbf3da8 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="mdescLeft">&#160;</td><td class="mdescRight">Coefficients of affine inequalities (in &gt;= 0 form).  <a href="classmlir_1_1IntegerPolyhedron.html#aec6b46b43e6b951daab2ac2cbfbf3da8">More...</a><br /></td></tr>
<tr class="separator:aec6b46b43e6b951daab2ac2cbfbf3da8 inherit pro_attribs_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:ac7022f51854ec1d369bb150035a1437f inherit pub_types_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">Kind</a> { <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa5d3c39d196a997e225b4f3ee3e1da745">Kind::FlatAffineConstraints</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa38bdec3fb5cb6b2e66b5acddb32f9cb4">Kind::FlatAffineValueConstraints</a>
 }<tr class="memdesc:ac7022f51854ec1d369bb150035a1437f"><td class="mdescLeft">&#160;</td><td class="mdescRight">All derived classes of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>.  <a href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac7022f51854ec1d369bb150035a1437f inherit pub_types_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eda5ed3d07648239f51a58d283af25f inherit pub_types_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a> { <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25fa819c60666bda38d2d84f3b3b1cc85353">EQ</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25fadbdfcad083981238050dde5e628d9906">LB</a>, 
<a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25fa6f0c4e378019df95f41471d395927fd4">UB</a>
 }<tr class="memdesc:a6eda5ed3d07648239f51a58d283af25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of bound: equal, lower bound or upper bound.  <a href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6eda5ed3d07648239f51a58d283af25f inherit pub_types_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmlir_1_1IntegerPolyhedron"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmlir_1_1IntegerPolyhedron')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmlir_1_1IntegerPolyhedron.html">mlir::IntegerPolyhedron</a></td></tr>
<tr class="memitem:a0e74388f8cbbd8cd5b47e9035592a5d8 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a> { <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8adb86e099c97d96d33d373cba8f860641">Dimension</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8a3769694bd380edd81de25eb77f9b6597">Symbol</a>, 
<a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8a5dfcedefe2c19bfd34ecc0e4f20cf0f3">Local</a>
 }<tr class="memdesc:a0e74388f8cbbd8cd5b47e9035592a5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kind of identifier (column).  <a href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a0e74388f8cbbd8cd5b47e9035592a5d8 inherit pub_types_classmlir_1_1IntegerPolyhedron"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classmlir_1_1FlatAffineConstraints"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classmlir_1_1FlatAffineConstraints')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classmlir_1_1FlatAffineConstraints.html">mlir::FlatAffineConstraints</a></td></tr>
<tr class="memitem:a436d362961b4fbd768187df180d6425d inherit pro_static_attribs_classmlir_1_1FlatAffineConstraints"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a436d362961b4fbd768187df180d6425d">kExplosionFactor</a> = 32</td></tr>
<tr class="memdesc:a436d362961b4fbd768187df180d6425d inherit pro_static_attribs_classmlir_1_1FlatAffineConstraints"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parameter that controls detection of an unrealistic number of constraints.  <a href="classmlir_1_1FlatAffineConstraints.html#a436d362961b4fbd768187df180d6425d">More...</a><br /></td></tr>
<tr class="separator:a436d362961b4fbd768187df180d6425d inherit pro_static_attribs_classmlir_1_1FlatAffineConstraints"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An extension of <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> in which dimensions and symbols can optionally be associated with an SSA value. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00434">434</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaec51cfb6129c7a10dbf24740897cf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec51cfb6129c7a10dbf24740897cf1b">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system reserving memory for the specified number of constraints and identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00438">438</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa5d3c39d196a997e225b4f3ee3e1da745">mlir::FlatAffineConstraints::FlatAffineConstraints</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00247">reset()</a>.</p>

</div>
</div>
<a id="a8ba51af6e35a94b11d73b5215a35ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba51af6e35a94b11d73b5215a35ff7a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a constraint system with the specified number of dimensions and symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00456">456</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::FlatAffineConstraints::FlatAffineValueConstraints</a>.</p>

</div>
</div>
<a id="ac652e97cab7cf64e3bef1b3418692a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac652e97cab7cf64e3bef1b3418692a2a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>fac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>valArgs</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00465">465</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa5d3c39d196a997e225b4f3ee3e1da745">mlir::FlatAffineConstraints::FlatAffineConstraints</a>, <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::FlatAffineConstraints::FlatAffineValueConstraints</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>.</p>

</div>
</div>
<a id="af048f5fb19968688b331c7bb0f8d9a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af048f5fb19968688b331c7bb0f8d9a4d">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>avm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a flat affine constraint system from an <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> or a list of these. </p>
<p>The constructed system will only include equalities. </p>

</div>
</div>
<a id="a0aa32c847534d57cff25fdfa654778e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aa32c847534d57cff25fdfa654778e0">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fa812729dd90454f1c10517520dde9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa812729dd90454f1c10517520dde9a">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an affine constraint system from an <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00190">190</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

</div>
</div>
<a id="a4c5a948d12b8760154eed1281249b0f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c5a948d12b8760154eed1281249b0f7">&#9670;&nbsp;</a></span>FlatAffineValueConstraints() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mlir::FlatAffineValueConstraints::FlatAffineValueConstraints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&gt;&#160;</td>
          <td class="paramname"><em>avmRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a85192d2ad28e90993950ec5c2598a3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85192d2ad28e90993950ec5c2598a3e7">&#9670;&nbsp;</a></span>addAffineForOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addAffineForOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for the specified 'affine.for' operation's <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> using IR information stored in its bound maps. </p>
<p>The right identifier is first looked up using <code>forOp</code>'s <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. Asserts if the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> corresponding to the 'affine.for' operation isn't found in the constraint system. Returns failure for the yet unimplemented/unsupported cases. Any new identifiers that are found in the bound operands of the 'affine.for' operation are added as trailing identifiers (either dimensional or symbolic depending on whether the operand is a valid symbol). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00585">585</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02115">addBound()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00101">mlir::IntegerPolyhedron::addEquality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02213">mlir::FlatAffineConstraints::addLocalFloorDiv()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02237">findId()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00119">mlir::IntegerPolyhedron::getNumCols()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00637">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00562">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02139">addSliceBounds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00214">mlir::getIndexSet()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1b74b3973d5329fe7ec99a7d2f8ed31f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b74b3973d5329fe7ec99a7d2f8ed31f">&#9670;&nbsp;</a></span>addAffineIfOpDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addAffineIfOpDomain </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints imposed by the <code>affine.if</code> operation. </p>
<p>These constraints are collected from the <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> attached to the given <code>affine.if</code> instance argument (<code>ifOp</code>). It is asserted that: 1) The <a class="el" href="classmlir_1_1IntegerSet.html" title="An integer set representing a conjunction of one or more affine equalities and inequalities. ">IntegerSet</a> of the given <code>affine.if</code> instance should not contain semi-affine expressions, 2) The columns of the constraint system created from <code>ifOp</code> should match the columns in the current one regarding numbers and values. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00686">686</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00038">mlir::IntegerPolyhedron::append()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00437">mergeAndAlignIdsWithOther()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00214">mlir::getIndexSet()</a>.</p>

</div>
</div>
<a id="ae0266a236d1adc4c4a08e4d68b741e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0266a236d1adc4c4a08e4d68b741e38">&#9670;&nbsp;</a></span>addBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bound for the identifier at the specified position with constraints being drawn from the specified bound map and operands. </p>
<p>In case of an EQ bound, the bound map is expected to have exactly one result. In case of a LB/UB, the bound map may have more than one result, for each of which an inequality is added. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02115">2115</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00562">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00879">mlir::canonicalizeMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02087">computeAlignedMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00705">mlir::fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00654">mlir::simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00585">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02267">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00637">addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00562">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00193">addLoopRangeConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02139">addSliceBounds()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00103">canonicalizeMinMaxOp()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00297">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="a210341fc77fde46aedce6d2609f26738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210341fc77fde46aedce6d2609f26738">&#9670;&nbsp;</a></span>addBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#a6eda5ed3d07648239f51a58d283af25f">BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a constant bound for the identifier associated with the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02267">2267</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02115">addBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02237">findId()</a>.</p>

</div>
</div>
<a id="a4287995c9f074be38e7e1d76b39d93f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4287995c9f074be38e7e1d76b39d93f8">&#9670;&nbsp;</a></span>addDomainFromSliceMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addDomainFromSliceMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds constraints (lower and upper bounds) for each loop in the loop nest described by the bound maps <code>lbMaps</code> and <code>ubMaps</code> of a computation slice. </p>
<p>Every pair (<code>lbMaps[i]</code>, <code>ubMaps[i]</code>) describes the bounds of a loop in the nest, sorted outer-to-inner. <code>operands</code> contains the bound operands for a single bound map. All the bound maps will use the same bound operands. Note that some loops described by a computation slice might not exist yet in the IR so the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> attached to those dimension identifiers might be empty. For that reason, this method doesn't perform <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> look-ups to retrieve the dimension identifier positions. Instead, it assumes the position of the dim identifiers in the constraint system is the same as the position of the loop in the loop nest. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00637">637</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00585">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02115">addBound()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00281">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01842">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00310">mlir::AffineDimExpr::getPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineExpr_8h_source.html#l00270">mlir::AffineExpr::isa()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>.</p>

</div>
</div>
<a id="a1150883739ccac33efedf30dd36decfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1150883739ccac33efedf30dd36decfb">&#9670;&nbsp;</a></span>addInductionVarOrTerminalSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::addInductionVarOrTerminalSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the specified values as a dim or symbol id depending on its nature, if it already doesn't exist in the system. </p>
<p><code>val</code> has to be either a terminal symbol or a loop IV, i.e., it cannot be the result affine.apply of any symbols or loop IVs. The identifier is added to the end of the existing dims or symbols. Additional information on the identifier is extracted from the IR and added to the constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00562">562</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00585">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02115">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00270">appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00276">appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02249">containsId()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="Value_8cpp_source.html#l00020">mlir::Value::getDefiningOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01842">mlir::getForInductionVarOwner()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01836">mlir::isForInductionVar()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00233">mlir::isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02115">addBound()</a>.</p>

</div>
</div>
<a id="ad38a7dd065a6c286b7ac84f0d1712c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38a7dd065a6c286b7ac84f0d1712c23">&#9670;&nbsp;</a></span>addSliceBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::addSliceBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>lbMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>ubMaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds slice lower bounds represented by lower bounds in <code>lbMaps</code> and upper bounds in <code>ubMaps</code> to each identifier in the constraint system which has a value in <code>values</code>. </p>
<p>Note that both lower/upper bounds share the same operand list <code>operands</code>. This function assumes <code>values.size</code> == <code>lbMaps.size</code> == <code>ubMaps.size</code>. Note that both lower/upper bounds use operands from <code>operands</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02139">2139</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00585">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02115">addBound()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00062">mlir::failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02237">findId()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01842">mlir::getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00302">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00315">mlir::AffineMap::getResult()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00056">mlir::success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>.</p>

</div>
</div>
<a id="a18111fe7ef555fcb69a9d6a175ea8cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18111fe7ef555fcb69a9d6a175ea8cd8">&#9670;&nbsp;</a></span>appendDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::appendDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append identifiers of the specified kind after the last identifier of that kind. </p>
<p>The coefficient columns corresponding to the added identifiers are initialized to zero. <code>vals</code> are the Values corresponding to the identifiers. Return the position of the first added column.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00270">270</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00562">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00193">addLoopRangeConstraints()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00103">canonicalizeMinMaxOp()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00297">mlir::scf::rewritePeeledMinMaxOp()</a>.</p>

</div>
</div>
<a id="a2c2a6f8c373783c6b808038d8c07e796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2a6f8c373783c6b808038d8c07e796">&#9670;&nbsp;</a></span>appendSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::appendSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00276">276</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00112">mlir::IntegerPolyhedron::getNumSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00562">addInductionVarOrTerminalSymbol()</a>, and <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>.</p>

</div>
</div>
<a id="a4fb1fae3bb100c4a3391e523712d2dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb1fae3bb100c4a3391e523712d2dba">&#9670;&nbsp;</a></span>areIdsAlignedWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::areIdsAlignedWithOther </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this constraint system and <code>other</code> are in the same space, i.e., if they are associated with the same set of identifiers, appearing in the same order. </p>
<p>Calls areIdsAligned to check if two constraint systems have the same set of identifiers in the same order.</p>
<p>Returns false otherwise.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00333">333</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00323">areIdsAligned()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a75831f7477271eec30108f8c58a2f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75831f7477271eec30108f8c58a2f2d0">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::FlatAffineValueConstraints::classof </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00503">503</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02039">mlir::FlatAffineConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00150">mlir::FlatAffineConstraints::clone()</a>, <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::FlatAffineConstraints::FlatAffineValueConstraints</a>, <a class="el" href="AffineStructures_8h_source.html#l00099">mlir::FlatAffineConstraints::getKind()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00055">mlir::IntegerPolyhedron::insertDimId()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00067">mlir::IntegerPolyhedron::insertId()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00059">mlir::IntegerPolyhedron::insertSymbolId()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00021">mlir::IntegerPolyhedron::reset()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00183">mlir::IntegerPolyhedron::swapId()</a>, and <a class="el" href="InterfaceSupport_8h_source.html#l00161">value</a>.</p>

</div>
</div>
<a id="afacc473110655fc94f713fa3733f8e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacc473110655fc94f713fa3733f8e9e">&#9670;&nbsp;</a></span>clearAndCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::clearAndCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the contents of this <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html" title="An extension of FlatAffineConstraints in which dimensions and symbols can optionally be associated wi...">FlatAffineValueConstraints</a> with <code>other</code>. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac662ea0313d9bcac2e44925b6be670e8">mlir::FlatAffineConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02673">2673</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02750">mlir::FlatAffineConstraints::fourierMotzkinEliminate()</a>.</p>

</div>
</div>
<a id="a592860df144ae17907bccf79792e3f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592860df144ae17907bccf79792e3f90">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &gt; FlatAffineValueConstraints::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clones this object. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00155">155</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ad4dd23a785eb9a02c7f2ba43fa1aa7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dd23a785eb9a02c7f2ba43fa1aa7db">&#9670;&nbsp;</a></span>composeMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::composeMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> *&#160;</td>
          <td class="paramname"><em>vMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Composes the affine value map with this FlatAffineValueConstrains, adding the results of the map as dimensions at the front [0, vMap-&gt;getNumResults()) and with the dimensions set to the equalities specified by the value map. </p>
<p>Returns failure if the composition fails (when vMap is a semi-affine map). The vMap's operand <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>'s are used to look up the right positions in the <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a> with which to associate. Every operand of vMap should have a matching dim/symbol column in this constraint system (with the same associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00443">443</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00451">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02087">computeAlignedMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00100">mlir::AffineValueMap::getAffineMap()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00096">mlir::AffineValueMap::getOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a5f1918c91299c463de63c843ee1f7628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1918c91299c463de63c843ee1f7628">&#9670;&nbsp;</a></span>computeAlignedMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> FlatAffineValueConstraints::computeAlignedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Align <code>map</code> with this constraint system based on <code>operands</code>. </p>
<p>Each operand must already have a corresponding dim/symbol in this constraint system. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02087">2087</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l03334">mlir::alignAffineMapWithValues()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00306">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00226">mlir::IntegerPolyhedron::numDims</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00230">mlir::IntegerPolyhedron::numSymbols</a>, and <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02115">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00443">composeMap()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a9d547b7f44aaa82af5d5ab1aeb74a42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d547b7f44aaa82af5d5ab1aeb74a42a">&#9670;&nbsp;</a></span>containsId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::containsId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if an identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> exists, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02249">2249</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00562">addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="a38b004fb4978436d8c8cd8976803468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b004fb4978436d8c8cd8976803468c">&#9670;&nbsp;</a></span>convertLoopIVSymbolsToDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::convertLoopIVSymbolsToDims </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes all symbol identifiers which are loop IVs to dim identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00549">549</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01842">mlir::getForInductionVarOwner()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00113">mlir::IntegerPolyhedron::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00706">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00712">hasValue()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00500">turnSymbolIntoDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="ab578264c931fe0f78eb0397943d032c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab578264c931fe0f78eb0397943d032c1">&#9670;&nbsp;</a></span>findId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::findId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the position of the identifier with the specified <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>
<p>Returns true if found (false otherwise). <code>pos</code> is set to the (column) position of the identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02237">2237</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00585">addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02267">addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02139">addSliceBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00430">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00513">mergeSymbolIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02959">projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00500">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="a30b3ca6765edfa5677b1b23130e0187c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3ca6765edfa5677b1b23130e0187c">&#9670;&nbsp;</a></span>fourierMotzkinEliminate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::fourierMotzkinEliminate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>darkShadow</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isResultIntegerExact</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Eliminates the identifier at the specified position using Fourier-Motzkin variable elimination, but uses Gaussian elimination if there is an equality involving that identifier. </p>
<p>If the result of the elimination is integer exact, <code>*isResultIntegerExact</code> is set to true. If <code>darkShadow</code> is set to true, a potential under approximation (subset) of the rational shadow / exact integer shadow is computed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a8a74c3f513f68972c677b4a104fe68b5">mlir::FlatAffineConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02911">2911</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02750">mlir::FlatAffineConstraints::fourierMotzkinEliminate()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00110">mlir::IntegerPolyhedron::getNumIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02924">mlir::FlatAffineConstraints::projectOut()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02959">projectOut()</a>.</p>

</div>
</div>
<a id="af5177b199aa494103835274f72907a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5177b199aa494103835274f72907a8b">&#9670;&nbsp;</a></span>getAllValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::getAllValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00728">728</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00179">mlir::linalg::getUpperBoundForIndex()</a>.</p>

</div>
</div>
<a id="acfee23f39d31078e69df752b973f53b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfee23f39d31078e69df752b973f53b6">&#9670;&nbsp;</a></span>getHyperrectangular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> FlatAffineValueConstraints::getHyperrectangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00207">207</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="ac0dbadcb953c32567a17ab1b662505e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dbadcb953c32567a17ab1b662505e0">&#9670;&nbsp;</a></span>getIneqAsAffineValueMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::getIneqAsAffineValueMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>ineqPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bound for the identifier at <code>pos</code> from the inequality at <code>ineqPos</code> as a 1-d affine value map (affine map + operands). </p>
<p>The returned affine value map can either be a lower bound or an upper bound depending on the sign of atIneq(ineqPos, pos). Asserts if the row at <code>ineqPos</code> does not involve the <code>pos</code>th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03181">3181</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l03151">computeLocalVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00072">mlir::failed()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00943">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00892">mlir::getAffineExprFromFlatForm()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00139">mlir::IntegerPolyhedron::getInequality()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00119">mlir::IntegerPolyhedron::getNumCols()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00113">mlir::IntegerPolyhedron::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00110">mlir::IntegerPolyhedron::getNumIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00123">mlir::IntegerPolyhedron::getNumInequalities()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00114">mlir::IntegerPolyhedron::getNumLocalIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00112">mlir::IntegerPolyhedron::getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00719">getValues()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00226">mlir::IntegerPolyhedron::numDims</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00019">mlir::AffineValueMap::reset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l03313">createFullTiles()</a>.</p>

</div>
</div>
<a id="ac6234845a4fa3eb9444e56cab0fe5b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6234845a4fa3eb9444e56cab0fe5b0e">&#9670;&nbsp;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437f">Kind</a> mlir::FlatAffineValueConstraints::getKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the kind of this <a class="el" href="classmlir_1_1FlatAffineConstraints.html" title="A flat list of affine equalities and inequalities in the form. ">FlatAffineConstraints</a>. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1FlatAffineConstraints.html#a4a09df05dc3bd81725f085f4268b7e6a">mlir::FlatAffineConstraints</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00501">501</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1FlatAffineConstraints.html#ac7022f51854ec1d369bb150035a1437fa38bdec3fb5cb6b2e66b5acddb32f9cb4">mlir::FlatAffineConstraints::FlatAffineValueConstraints</a>.</p>

</div>
</div>
<a id="a0d108d7e10610afd56b9bc03598741f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d108d7e10610afd56b9bc03598741f9">&#9670;&nbsp;</a></span>getMaybeDimAndSymbolValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeDimAndSymbolValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00744">744</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00112">mlir::IntegerPolyhedron::getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00103">canonicalizeMinMaxOp()</a>.</p>

</div>
</div>
<a id="a1e61e7f65a2ddd3fb4dc389d1fcd4467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e61e7f65a2ddd3fb4dc389d1fcd4467">&#9670;&nbsp;</a></span>getMaybeDimValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeDimValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00736">736</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03394">mlir::FlatAffineRelation::compose()</a>.</p>

</div>
</div>
<a id="a464901024f611db773f2def48443b8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464901024f611db773f2def48443b8f8">&#9670;&nbsp;</a></span>getMaybeSymbolValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeSymbolValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00740">740</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, and <a class="el" href="IntegerPolyhedron_8h_source.html#l00112">mlir::IntegerPolyhedron::getNumSymbolIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00040">alignAndAddBound()</a>.</p>

</div>
</div>
<a id="ad7998d8323c934c13a86769ca8fad877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7998d8323c934c13a86769ca8fad877">&#9670;&nbsp;</a></span>getMaybeValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt; &gt; mlir::FlatAffineValueConstraints::getMaybeValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00732">732</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00323">areIdsAligned()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00340">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03128">unionBoundingBox()</a>.</p>

</div>
</div>
<a id="a3896e7ab007a7bd1e8d1fb1fb098bdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896e7ab007a7bd1e8d1fb1fb098bdea">&#9670;&nbsp;</a></span>getValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::FlatAffineValueConstraints::getValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> identifier was associated. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00706">706</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00763">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03394">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00549">convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00430">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00277">getCommonBlock()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00255">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00513">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="a9ccc790e216f3bbf7416308c04045094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ccc790e216f3bbf7416308c04045094">&#9670;&nbsp;</a></span>getValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::getValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Values associated with identifiers in range [start, end). </p>
<p>Asserts if no <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> was associated with one of these identifiers. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00719">719</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l03231">createSeparationCondition()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02606">generateCopy()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03181">getIneqAsAffineValueMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00513">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="a3202cddcf31d0798de72cac6742248b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3202cddcf31d0798de72cac6742248b0">&#9670;&nbsp;</a></span>hasConsistentState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasConsistentState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns false if the fields corresponding to various identifier counts, or equality/inequality buffer sizes aren't consistent; true otherwise. </p>
<p>This is meant to be used within an assert internally. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a3b85a47632adfb7c5c15bb2fccdb6492">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00750">750</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00110">mlir::IntegerPolyhedron::getNumIds()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00275">mlir::IntegerPolyhedron::hasConsistentState()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02750">mlir::FlatAffineConstraints::fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01274">mlir::FlatAffineConstraints::gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00755">mlir::FlatAffineConstraints::hasInvalidConstraint()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00925">mlir::FlatAffineConstraints::isEmptyByGCDTest()</a>.</p>

</div>
</div>
<a id="a5e39afc73e0776e068eb7331bcb349c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e39afc73e0776e068eb7331bcb349c7">&#9670;&nbsp;</a></span>hasValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::FlatAffineValueConstraints::hasValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the pos^th identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00712">712</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03394">mlir::FlatAffineRelation::compose()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00549">convertLoopIVSymbolsToDims()</a>.</p>

</div>
</div>
<a id="a321a6a4ea45324a6c969a5b5062ec932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321a6a4ea45324a6c969a5b5062ec932">&#9670;&nbsp;</a></span>hasValues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FlatAffineValueConstraints::hasValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if at least one identifier has an associated <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00315">315</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

</div>
</div>
<a id="a37618dd64a6fe91226805818e4139fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37618dd64a6fe91226805818e4139fb9">&#9670;&nbsp;</a></span>insertDimId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertDimId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert identifiers of the specified kind at position <code>pos</code>. </p>
<p>Positions are relative to the kind of identifier. The coefficient columns corresponding to the added identifiers are initialized to zero. <code>vals</code> are the Values corresponding to the identifiers. Return the absolute column position (i.e., not relative to the kind of identifier) of the first added identifier.</p>
<p>Note: Empty Values are allowed in <code>vals</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00282">282</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03479">mlir::FlatAffineRelation::appendDomainId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03484">mlir::FlatAffineRelation::appendRangeId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00451">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00379">computeDirectionVector()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03465">mlir::FlatAffineRelation::insertDomainId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03472">mlir::FlatAffineRelation::insertRangeId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a7dde72b54f749643d4002efc28a643a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dde72b54f749643d4002efc28a643a0">&#9670;&nbsp;</a></span>insertId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>num</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0dca9587b920bc5347b689a2f29695cd">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00292">292</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00270">appendDimId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00276">appendSymbolId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00282">insertDimId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00287">insertSymbolId()</a>.</p>

</div>
</div>
<a id="a5a31a532a6942ad1f960d6663ab8fede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a31a532a6942ad1f960d6663ab8fede">&#9670;&nbsp;</a></span>insertId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0e74388f8cbbd8cd5b47e9035592a5d8">IdKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00300">300</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

</div>
</div>
<a id="a99c6ee75c0627beaeb455d0428636849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c6ee75c0627beaeb455d0428636849">&#9670;&nbsp;</a></span>insertSymbolId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> FlatAffineValueConstraints::insertSymbolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00287">287</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00292">insertId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00513">mergeSymbolIds()</a>.</p>

</div>
</div>
<a id="ad2eed02898a13f56e0bc2a470c2f89af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eed02898a13f56e0bc2a470c2f89af">&#9670;&nbsp;</a></span>mergeAndAlignIdsWithOther()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::mergeAndAlignIdsWithOther </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align the identifiers of <code>this</code> and <code>other</code> starting at <code>offset</code>, so that both constraint systems get the union of the contained identifiers that is dimension-wise and symbol-wise unique; both constraint systems are updated so that they have the union of all identifiers, with <code>this</code>'s original identifiers appearing first followed by any of <code>other</code>'s identifiers that didn't appear in <code>this</code>. </p>
<p>Local identifiers in <code>other</code> that have the same division representation as local identifiers in <code>this</code> are merged into one. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00437">437</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00686">addAffineIfOpDomain()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a5333879b7e111caf2c3371c0d0745296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5333879b7e111caf2c3371c0d0745296">&#9670;&nbsp;</a></span>mergeSymbolIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::mergeSymbolIds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge and align symbols of <code>this</code> and <code>other</code> such that both get union of of symbols that are unique. </p>
<p>Symbols in <code>this</code> and <code>other</code> should be unique. Symbols with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> as <code>None</code> are considered to be inequal to all other symbols. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00513">513</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00340">areIdsUnique()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02237">findId()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00113">mlir::IntegerPolyhedron::getNumDimAndSymbolIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00112">mlir::IntegerPolyhedron::getNumSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00706">getValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00719">getValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00287">insertSymbolId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02255">swapId()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03394">mlir::FlatAffineRelation::compose()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>.</p>

</div>
</div>
<a id="a79575e2c2693576f2c5a4accf0dcdab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79575e2c2693576f2c5a4accf0dcdab6">&#9670;&nbsp;</a></span>projectOut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::projectOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Projects out the identifier that is associate with <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02959">2959</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02237">findId()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02911">fourierMotzkinEliminate()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02486">mlir::FlatAffineConstraints::computeConstantLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00379">computeDirectionVector()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l01045">mlir::getComputationSliceState()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00221">mlir::ComputationSliceState::isSliceValid()</a>.</p>

</div>
</div>
<a id="a2b415d11d42c0a1e02bc2c35833d3a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b415d11d42c0a1e02bc2c35833d3a2d">&#9670;&nbsp;</a></span>removeIdRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::removeIdRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>idLimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes identifiers in the column range [idStart, idLimit), and copies any remaining valid data into place, updates member variables, and resizes arrays as needed. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#a0b9f60a450b02d29b4cc693f730dc780">mlir::IntegerPolyhedron</a>.</p>

<p>Reimplemented in <a class="el" href="classmlir_1_1FlatAffineRelation.html#a1d7c7d7e81a2975456aca816950b0f0c">mlir::FlatAffineRelation</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00820">820</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00121">mlir::IntegerPolyhedron::removeIdRange()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01736">mlir::FlatAffineConstraints::convertDimToLocal()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01274">mlir::FlatAffineConstraints::gaussianEliminateIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03450">mlir::FlatAffineRelation::inverse()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03489">mlir::FlatAffineRelation::removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02306">mlir::FlatAffineConstraints::setAndEliminate()</a>.</p>

</div>
</div>
<a id="ad9813ab39fe84ac3208f6475c0058e02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9813ab39fe84ac3208f6475c0058e02">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears any existing data and reserves memory for the specified constraints. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#aade68321941df8db9b3ec9dc97f1ffbb">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00237">237</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00440">checkTilingLegalityImpl()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00214">mlir::getIndexSet()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00069">mlir::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00291">mlir::ComputationSliceState::isMaximal()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00262">reset()</a>.</p>

</div>
</div>
<a id="a58e00fa2f257f1bd2c8ab11369207198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58e00fa2f257f1bd2c8ab11369207198">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedInequalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedEqualities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numReservedCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00247">247</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8h_source.html#l00438">FlatAffineValueConstraints()</a>.</p>

</div>
</div>
<a id="ae3a94ce5a825b81e5767fef38db2329a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a94ce5a825b81e5767fef38db2329a">&#9670;&nbsp;</a></span>reset() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>numLocals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>valArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00262">262</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00237">reset()</a>.</p>

</div>
</div>
<a id="a5eccad1d331cf5cfb78bf1f08fda7224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eccad1d331cf5cfb78bf1f08fda7224">&#9670;&nbsp;</a></span>setValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::setValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> associated with the pos^th identifier. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00749">749</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l03394">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00430">mlir::MemRefAccess::getAccessRelation()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03544">mlir::getRelationFromMap()</a>.</p>

</div>
</div>
<a id="a320c65d604a6089bb16894e4a9ee33bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320c65d604a6089bb16894e4a9ee33bf">&#9670;&nbsp;</a></span>setValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::FlatAffineValueConstraints::setValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Values associated with the identifiers in the range [start, end). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00755">755</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l02750">mlir::FlatAffineConstraints::fourierMotzkinEliminate()</a>, <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00275">mlir::IntegerPolyhedron::hasConsistentState()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00223">mlir::IntegerPolyhedron::numIds</a>, and <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00121">mlir::IntegerPolyhedron::removeIdRange()</a>.</p>

</div>
</div>
<a id="acda87dfc4340eb857e9bc9ab05141b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda87dfc4340eb857e9bc9ab05141b16">&#9670;&nbsp;</a></span>swapId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> FlatAffineValueConstraints::swapId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>posB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap the posA^th identifier with the posB^th identifier. </p>

<p>Reimplemented from <a class="el" href="classmlir_1_1IntegerPolyhedron.html#aa591bcb71980075a8e8aea52bc0df0cc">mlir::IntegerPolyhedron</a>.</p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l02255">2255</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerPolyhedron_8cpp_source.html#l00183">mlir::IntegerPolyhedron::swapId()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00794">values</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01736">mlir::FlatAffineConstraints::convertDimToLocal()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00430">mlir::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03450">mlir::FlatAffineRelation::inverse()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00513">mergeSymbolIds()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00500">turnSymbolIntoDim()</a>.</p>

</div>
</div>
<a id="af0c35f1d2d81adf4ba06b84df578cd78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c35f1d2d81adf4ba06b84df578cd78">&#9670;&nbsp;</a></span>unionBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> FlatAffineValueConstraints::unionBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the constraints to be the smallest bounding (enclosing) box that contains the points of <code>this</code> set and that of <code>other</code>, with the symbols being treated specially. </p>
<p>For each of the dimensions, the min of the lower bounds (symbolic) and the max of the upper bounds (symbolic) is computed to determine such a bounding box. <code>other</code> is expected to have the same dimensional identifiers as this constraint system (in the same order).</p>
<p>E.g.: 1) this = {0 &lt;= d0 &lt;= 127}, other = {16 &lt;= d0 &lt;= 192}, output = {0 &lt;= d0 &lt;= 192} 2) this = {s0 + 5 &lt;= d0 &lt;= s0 + 20}, other = {s0 + 1 &lt;= d0 &lt;= s0 + 9}, output = {s0 + 1 &lt;= d0 &lt;= s0 + 20} 3) this = {0 &lt;= d0 &lt;= 5, 1 &lt;= d1 &lt;= 9} other = {2 &lt;= d0 &lt;= 6, 5 &lt;= d1 &lt;= 15}, output = {0 &lt;= d0 &lt;= 6, 1 &lt;= d1 &lt;= 15} </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l03128">3128</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00323">areIdsAligned()</a>, <a class="el" href="AffineStructures_8h_source.html#l00732">getMaybeValues()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00111">mlir::IntegerPolyhedron::getNumDimIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00114">mlir::IntegerPolyhedron::getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00387">mergeAndAlignIds()</a>, <a class="el" href="IntegerPolyhedron_8h_source.html#l00226">mlir::IntegerPolyhedron::numDims</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l03017">mlir::FlatAffineConstraints::unionBoundingBox()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00811">mlir::computeSliceUnion()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2662045a8d845c7cf9aa9516af6ea914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2662045a8d845c7cf9aa9516af6ea914">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;, 8&gt; mlir::FlatAffineValueConstraints::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Values corresponding to the (column) identifiers of this constraint system appearing in the order the identifiers correspond to columns. </p>
<p>Temporary ones or those that aren't associated with any <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> are set to None. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8h_source.html#l00794">794</a> of file <a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l02673">clearAndCopyFrom()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l03394">mlir::FlatAffineRelation::compose()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02087">computeAlignedMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02249">containsId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02237">findId()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00190">FlatAffineValueConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02911">fourierMotzkinEliminate()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00750">hasConsistentState()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00315">hasValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00820">removeIdRange()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02255">swapId()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Analysis/<a class="el" href="AffineStructures_8h_source.html">AffineStructures.h</a></li>
<li>lib/Analysis/<a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 29 2021 16:37:16 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
